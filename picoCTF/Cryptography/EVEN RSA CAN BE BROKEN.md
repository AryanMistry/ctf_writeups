# EVEN RSA CAN BE BROKEN??? - picoCTF 2025 Writeup

**Category:** Cryptography  
**Difficulty:** Easy

## Description
This service provides you an encrypted flag. Can you decrypt it with just N & e?

## Background
RSA is an asymmetric cryptosystem used for secure data transfer and digital signatures.  
Normally:
- `N = p * q`, where `p` and `q` are large prime numbers (and therefore odd).  
- Encryption: `c = m^e mod N`  
- Decryption: `m = c^d mod N` where `d ≡ e^(-1) mod φ(N)`  
- Euler’s totient: `φ(N) = (p-1)(q-1)`  

The security of this RSA cryptosystem is that it is very difficult to factor `N` in order to calculate `φ(N)`

## Approach
Connecting to the server via `netcat`, we are given 3 values: `N`,`e`, and the `cyphertext`.

```bash
$ nc verbal-sleep.picoctf.net 58721
N: 14886330364962802230621366545252475836214670322736009146497091598302940509825098050412453622257819554443084960059305894879529530056992992621064237153693102
e: 65537
cyphertext: 2903633876327074545620302656293627901919747130774147909045697320024185456287347274241968500272853378775945490891107745994115790763054558060454560579300641

$ nc verbal-sleep.picoctf.net 58721
N: 21655854510460184607747093434103304544730905331691927885599193192939730595288519461836507850262871566523294285044406122256160612436082460791172217151291774
e: 65537
cyphertext: 6756954650882668577845330556299965389748113536893965479260574942884576172211104441173617656617505525484367496961846777189424743157606971158434322015837283
    
$ nc verbal-sleep.picoctf.net 58721
N: 26192116414646638802960842209858122399106231451223494328658038765496208519314233622864172634014257942730170235337039040650129427691813641403741450372591082
e: 65537
cyphertext: 14384873268526403467865136662000768701547739374149729839367308511359694991684849514153233220645055961729703658903987725475605144607863854981933298346806795

$ nc verbal-sleep.picoctf.net 58721
N: 22126072180230078308468476547631481444555860304356018932776170096342744252336161103171974192409852168238654691248197511343528090033327751284968230661911694
e: 65537
cyphertext: 6932895028669141228436836473466972193965934187556441079800947870040347735826736909535965508216571242106420770178883444750637827807031038268485709226763059

$ nc verbal-sleep.picoctf.net 58721
N: 15649864975267512509097031044687040882720062135380519844266884454469047660206509400133872224931144636400234652138663146054106284589687780872747927709508622
e: 65537
cyphertext: 670180262813520571264730072340329794688187655204278491787636175745081282769148754824134511252753703346959623539713481723408755659578474522076535754509497
```

While examining the values of `N`, I noticed that they are all even. This is the attack vector since if `N` is even, it means that one of its factors must be `2`

So, we can immediately calculate `p` and `q`, `φ(N)`, and `d` to compute the decryption equation `m = c^d mod N` and get the plaintext. 

## Solution
Here is a Python script to get the flag.
```Python
from Crypto.Util.number import long_to_bytes

# Given values
N = 22952767426310255116948069979828903923176912862995126428957200057833691132544816333101206252253814833951686520908362571114738760042764047607726784642073434
e = 65537
c = 700406502525108084791799270348672159219758358780880299048896254769487055031493945930484575728341052482800279944604336191947025602241107050228507777853749

# Factor N
p = 2
q = N // 2

# Compute φ(N)
phi = (p - 1) * (q - 1)

# Compute d 
d = pow(e, -1, phi)

# Decrypt ciphertext
m = pow(c, d, N)

# Convert integer to bytes
flag = long_to_bytes(m)
print(flag)
```

Output
```bash
b'picoCTF{...redacted...}'
```

The flaw in this challenge was that N was even which meant one factor was 2, making factorization trivial. This shows why RSA security completely depends on choosing two large, random odd primes. If either factor is small or predictable, RSA is instantly broken.